// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module sui_inscription::slot {
    use std::option;
    use sui::event;
    use sui::object::{Self, ID, UID};
    use sui::table;
    use sui::transfer;
    use sui::tx_context::TxContext;
    friend sui_inscription::slot_create_logic;
    friend sui_inscription::slot_put_up_candidate_logic;
    friend sui_inscription::slot_advance_logic;
    friend sui_inscription::slot_aggregate;

    const EIdAlreadyExists: u64 = 101;
    #[allow(unused_const)]
    const EDataTooLong: u64 = 102;
    const EInappropriateVersion: u64 = 103;

    struct SlotNumberTable has key {
        id: UID,
        table: table::Table<u8, object::ID>,
    }

    struct SlotNumberTableCreated has copy, drop {
        id: object::ID,
    }

    fun init(ctx: &mut TxContext) {
        let id_generator_table = SlotNumberTable {
            id: object::new(ctx),
            table: table::new(ctx),
        };
        let id_generator_table_id = object::uid_to_inner(&id_generator_table.id);
        transfer::share_object(id_generator_table);
        event::emit(SlotNumberTableCreated {
            id: id_generator_table_id,
        });
    }

    struct Slot has key {
        id: UID,
        slot_number: u8,
        version: u64,
        genesis_timestamp: u64,
        minted_amount: u64,
        round: u64,
        qualified_round: u64,
        qualified_inscription_id: ID,
        qualified_hash: vector<u8>,
        qualified_timestamp: u64,
        qualified_difference: u64,
        candidate_inscription_id: ID,
        candidate_hash: vector<u8>,
        candidate_timestamp: u64,
        candidate_difference: u64,
    }

    public fun id(slot: &Slot): object::ID {
        object::uid_to_inner(&slot.id)
    }

    public fun slot_number(slot: &Slot): u8 {
        slot.slot_number
    }

    public fun version(slot: &Slot): u64 {
        slot.version
    }

    public fun genesis_timestamp(slot: &Slot): u64 {
        slot.genesis_timestamp
    }

    public(friend) fun set_genesis_timestamp(slot: &mut Slot, genesis_timestamp: u64) {
        slot.genesis_timestamp = genesis_timestamp;
    }

    public fun minted_amount(slot: &Slot): u64 {
        slot.minted_amount
    }

    public(friend) fun set_minted_amount(slot: &mut Slot, minted_amount: u64) {
        slot.minted_amount = minted_amount;
    }

    public fun round(slot: &Slot): u64 {
        slot.round
    }

    public(friend) fun set_round(slot: &mut Slot, round: u64) {
        slot.round = round;
    }

    public fun qualified_round(slot: &Slot): u64 {
        slot.qualified_round
    }

    public(friend) fun set_qualified_round(slot: &mut Slot, qualified_round: u64) {
        slot.qualified_round = qualified_round;
    }

    public fun qualified_inscription_id(slot: &Slot): ID {
        slot.qualified_inscription_id
    }

    public(friend) fun set_qualified_inscription_id(slot: &mut Slot, qualified_inscription_id: ID) {
        slot.qualified_inscription_id = qualified_inscription_id;
    }

    public fun qualified_hash(slot: &Slot): vector<u8> {
        slot.qualified_hash
    }

    public(friend) fun set_qualified_hash(slot: &mut Slot, qualified_hash: vector<u8>) {
        slot.qualified_hash = qualified_hash;
    }

    public fun qualified_timestamp(slot: &Slot): u64 {
        slot.qualified_timestamp
    }

    public(friend) fun set_qualified_timestamp(slot: &mut Slot, qualified_timestamp: u64) {
        slot.qualified_timestamp = qualified_timestamp;
    }

    public fun qualified_difference(slot: &Slot): u64 {
        slot.qualified_difference
    }

    public(friend) fun set_qualified_difference(slot: &mut Slot, qualified_difference: u64) {
        slot.qualified_difference = qualified_difference;
    }

    public fun candidate_inscription_id(slot: &Slot): ID {
        slot.candidate_inscription_id
    }

    public(friend) fun set_candidate_inscription_id(slot: &mut Slot, candidate_inscription_id: ID) {
        slot.candidate_inscription_id = candidate_inscription_id;
    }

    public fun candidate_hash(slot: &Slot): vector<u8> {
        slot.candidate_hash
    }

    public(friend) fun set_candidate_hash(slot: &mut Slot, candidate_hash: vector<u8>) {
        slot.candidate_hash = candidate_hash;
    }

    public fun candidate_timestamp(slot: &Slot): u64 {
        slot.candidate_timestamp
    }

    public(friend) fun set_candidate_timestamp(slot: &mut Slot, candidate_timestamp: u64) {
        slot.candidate_timestamp = candidate_timestamp;
    }

    public fun candidate_difference(slot: &Slot): u64 {
        slot.candidate_difference
    }

    public(friend) fun set_candidate_difference(slot: &mut Slot, candidate_difference: u64) {
        slot.candidate_difference = candidate_difference;
    }

    fun new_slot(
        slot_number: u8,
        genesis_timestamp: u64,
        minted_amount: u64,
        qualified_round: u64,
        qualified_inscription_id: ID,
        qualified_hash: vector<u8>,
        qualified_timestamp: u64,
        qualified_difference: u64,
        candidate_inscription_id: ID,
        candidate_hash: vector<u8>,
        candidate_timestamp: u64,
        candidate_difference: u64,
        ctx: &mut TxContext,
    ): Slot {
        Slot {
            id: object::new(ctx),
            slot_number,
            version: 0,
            genesis_timestamp,
            minted_amount,
            round: 0,
            qualified_round,
            qualified_inscription_id,
            qualified_hash,
            qualified_timestamp,
            qualified_difference,
            candidate_inscription_id,
            candidate_hash,
            candidate_timestamp,
            candidate_difference,
        }
    }

    struct SlotCreated has copy, drop {
        id: option::Option<object::ID>,
        slot_number: u8,
        genesis_timestamp: u64,
        minted_amount: u64,
        qualified_round: u64,
        qualified_inscription_id: ID,
        qualified_hash: vector<u8>,
        qualified_timestamp: u64,
        qualified_difference: u64,
        candidate_inscription_id: ID,
        candidate_hash: vector<u8>,
        candidate_timestamp: u64,
        candidate_difference: u64,
    }

    public fun slot_created_id(slot_created: &SlotCreated): option::Option<object::ID> {
        slot_created.id
    }

    public(friend) fun set_slot_created_id(slot_created: &mut SlotCreated, id: object::ID) {
        slot_created.id = option::some(id);
    }

    public fun slot_created_slot_number(slot_created: &SlotCreated): u8 {
        slot_created.slot_number
    }

    public fun slot_created_genesis_timestamp(slot_created: &SlotCreated): u64 {
        slot_created.genesis_timestamp
    }

    public fun slot_created_minted_amount(slot_created: &SlotCreated): u64 {
        slot_created.minted_amount
    }

    public fun slot_created_qualified_round(slot_created: &SlotCreated): u64 {
        slot_created.qualified_round
    }

    public fun slot_created_qualified_inscription_id(slot_created: &SlotCreated): ID {
        slot_created.qualified_inscription_id
    }

    public fun slot_created_qualified_hash(slot_created: &SlotCreated): vector<u8> {
        slot_created.qualified_hash
    }

    public fun slot_created_qualified_timestamp(slot_created: &SlotCreated): u64 {
        slot_created.qualified_timestamp
    }

    public fun slot_created_qualified_difference(slot_created: &SlotCreated): u64 {
        slot_created.qualified_difference
    }

    public fun slot_created_candidate_inscription_id(slot_created: &SlotCreated): ID {
        slot_created.candidate_inscription_id
    }

    public fun slot_created_candidate_hash(slot_created: &SlotCreated): vector<u8> {
        slot_created.candidate_hash
    }

    public fun slot_created_candidate_timestamp(slot_created: &SlotCreated): u64 {
        slot_created.candidate_timestamp
    }

    public fun slot_created_candidate_difference(slot_created: &SlotCreated): u64 {
        slot_created.candidate_difference
    }

    public(friend) fun new_slot_created(
        slot_number: u8,
        genesis_timestamp: u64,
        minted_amount: u64,
        qualified_round: u64,
        qualified_inscription_id: ID,
        qualified_hash: vector<u8>,
        qualified_timestamp: u64,
        qualified_difference: u64,
        candidate_inscription_id: ID,
        candidate_hash: vector<u8>,
        candidate_timestamp: u64,
        candidate_difference: u64,
    ): SlotCreated {
        SlotCreated {
            id: option::none(),
            slot_number,
            genesis_timestamp,
            minted_amount,
            qualified_round,
            qualified_inscription_id,
            qualified_hash,
            qualified_timestamp,
            qualified_difference,
            candidate_inscription_id,
            candidate_hash,
            candidate_timestamp,
            candidate_difference,
        }
    }

    struct CandidateInscriptionPutUp has copy, drop {
        id: object::ID,
        slot_number: u8,
        version: u64,
        cadidate_inscription_id: ID,
    }

    public fun candidate_inscription_put_up_id(candidate_inscription_put_up: &CandidateInscriptionPutUp): object::ID {
        candidate_inscription_put_up.id
    }

    public fun candidate_inscription_put_up_slot_number(candidate_inscription_put_up: &CandidateInscriptionPutUp): u8 {
        candidate_inscription_put_up.slot_number
    }

    public fun candidate_inscription_put_up_cadidate_inscription_id(candidate_inscription_put_up: &CandidateInscriptionPutUp): ID {
        candidate_inscription_put_up.cadidate_inscription_id
    }

    public(friend) fun new_candidate_inscription_put_up(
        slot: &Slot,
        cadidate_inscription_id: ID,
    ): CandidateInscriptionPutUp {
        CandidateInscriptionPutUp {
            id: id(slot),
            slot_number: slot_number(slot),
            version: version(slot),
            cadidate_inscription_id,
        }
    }

    struct SlotAdvanced has copy, drop {
        id: object::ID,
        slot_number: u8,
        version: u64,
        cadidate_inscription_id: ID,
        witness_inscription_id: ID,
    }

    public fun slot_advanced_id(slot_advanced: &SlotAdvanced): object::ID {
        slot_advanced.id
    }

    public fun slot_advanced_slot_number(slot_advanced: &SlotAdvanced): u8 {
        slot_advanced.slot_number
    }

    public fun slot_advanced_cadidate_inscription_id(slot_advanced: &SlotAdvanced): ID {
        slot_advanced.cadidate_inscription_id
    }

    public fun slot_advanced_witness_inscription_id(slot_advanced: &SlotAdvanced): ID {
        slot_advanced.witness_inscription_id
    }

    public(friend) fun new_slot_advanced(
        slot: &Slot,
        cadidate_inscription_id: ID,
        witness_inscription_id: ID,
    ): SlotAdvanced {
        SlotAdvanced {
            id: id(slot),
            slot_number: slot_number(slot),
            version: version(slot),
            cadidate_inscription_id,
            witness_inscription_id,
        }
    }


    public(friend) fun create_slot(
        slot_number: u8,
        genesis_timestamp: u64,
        minted_amount: u64,
        qualified_round: u64,
        qualified_inscription_id: ID,
        qualified_hash: vector<u8>,
        qualified_timestamp: u64,
        qualified_difference: u64,
        candidate_inscription_id: ID,
        candidate_hash: vector<u8>,
        candidate_timestamp: u64,
        candidate_difference: u64,
        slot_number_table: &mut SlotNumberTable,
        ctx: &mut TxContext,
    ): Slot {
        let slot = new_slot(
            slot_number,
            genesis_timestamp,
            minted_amount,
            qualified_round,
            qualified_inscription_id,
            qualified_hash,
            qualified_timestamp,
            qualified_difference,
            candidate_inscription_id,
            candidate_hash,
            candidate_timestamp,
            candidate_difference,
            ctx,
        );
        asset_slot_number_not_exists_then_add(slot_number, slot_number_table, object::uid_to_inner(&slot.id));
        slot
    }

    public(friend) fun asset_slot_number_not_exists(
        slot_number: u8,
        slot_number_table: &SlotNumberTable,
    ) {
        assert!(!table::contains(&slot_number_table.table, slot_number), EIdAlreadyExists);
    }

    fun asset_slot_number_not_exists_then_add(
        slot_number: u8,
        slot_number_table: &mut SlotNumberTable,
        id: object::ID,
    ) {
        asset_slot_number_not_exists(slot_number, slot_number_table);
        table::add(&mut slot_number_table.table, slot_number, id);
    }

    public(friend) fun transfer_object(slot: Slot, recipient: address) {
        assert!(slot.version == 0, EInappropriateVersion);
        transfer::transfer(slot, recipient);
    }

    public(friend) fun update_version_and_transfer_object(slot: Slot, recipient: address) {
        update_object_version(&mut slot);
        transfer::transfer(slot, recipient);
    }

    #[lint_allow(share_owned)]
    public(friend) fun share_object(slot: Slot) {
        assert!(slot.version == 0, EInappropriateVersion);
        transfer::share_object(slot);
    }

    #[lint_allow(share_owned)]
    public(friend) fun update_version_and_share_object(slot: Slot) {
        update_object_version(&mut slot);
        transfer::share_object(slot);
    }

    public(friend) fun freeze_object(slot: Slot) {
        assert!(slot.version == 0, EInappropriateVersion);
        transfer::freeze_object(slot);
    }

    public(friend) fun update_version_and_freeze_object(slot: Slot) {
        update_object_version(&mut slot);
        transfer::freeze_object(slot);
    }

    public(friend) fun update_object_version(slot: &mut Slot) {
        slot.version = slot.version + 1;
        //assert!(slot.version != 0, EInappropriateVersion);
    }

    public(friend) fun drop_slot(slot: Slot) {
        let Slot {
            id,
            version: _version,
            slot_number: _slot_number,
            genesis_timestamp: _genesis_timestamp,
            minted_amount: _minted_amount,
            round: _round,
            qualified_round: _qualified_round,
            qualified_inscription_id: _qualified_inscription_id,
            qualified_hash: _qualified_hash,
            qualified_timestamp: _qualified_timestamp,
            qualified_difference: _qualified_difference,
            candidate_inscription_id: _candidate_inscription_id,
            candidate_hash: _candidate_hash,
            candidate_timestamp: _candidate_timestamp,
            candidate_difference: _candidate_difference,
        } = slot;
        object::delete(id);
    }

    public(friend) fun emit_slot_created(slot_created: SlotCreated) {
        event::emit(slot_created);
    }

    public(friend) fun emit_candidate_inscription_put_up(candidate_inscription_put_up: CandidateInscriptionPutUp) {
        event::emit(candidate_inscription_put_up);
    }

    public(friend) fun emit_slot_advanced(slot_advanced: SlotAdvanced) {
        event::emit(slot_advanced);
    }

    #[test_only]
    /// Wrapper of module initializer for testing
    public fun test_init(ctx: &mut TxContext) {
        init(ctx)
    }

}
