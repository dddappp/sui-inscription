// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module sui_inscription::slot {
    use std::option;
    use std::string::String;
    use sui::event;
    use sui::object::{Self, ID, UID};
    use sui::table;
    use sui::transfer;
    use sui::tx_context::TxContext;
    friend sui_inscription::slot_create_logic;
    friend sui_inscription::slot_put_up_candidate_logic;
    friend sui_inscription::slot_advance_logic;
    friend sui_inscription::slot_aggregate;

    const EIdAlreadyExists: u64 = 101;
    #[allow(unused_const)]
    const EDataTooLong: u64 = 102;
    const EInappropriateVersion: u64 = 103;
    const EEmptyObjectID: u64 = 107;

    /// Not the right admin for the object
    const ENotAdmin: u64 = 0;
    /// Migration is not an upgrade
    const ENotUpgrade: u64 = 1;
    /// Calling functions from the wrong package version
    const EWrongSchemaVersion: u64 = 2;

    const SCHEMA_VERSION: u64 = 0;

    struct AdminCap has key {
        id: UID,
    }


    struct SlotNumberTable has key {
        id: UID,
        table: table::Table<u8, object::ID>,
    }

    struct SlotNumberTableCreated has copy, drop {
        id: object::ID,
    }

    fun init(ctx: &mut TxContext) {
        let id_generator_table = SlotNumberTable {
            id: object::new(ctx),
            table: table::new(ctx),
        };
        let id_generator_table_id = object::uid_to_inner(&id_generator_table.id);
        transfer::share_object(id_generator_table);
        event::emit(SlotNumberTableCreated {
            id: id_generator_table_id,
        });
    }

    public fun asssert_schema_version(slot: &Slot) {
        assert_schema_version(slot);
    }

    public fun assert_schema_version(slot: &Slot) {
        assert!(slot.schema_version == SCHEMA_VERSION, EWrongSchemaVersion);
    }

    struct Slot has key {
        id: UID,
        slot_number: u8,
        version: u64,
        schema_version: u64,
        admin_cap: ID,
        genesis_timestamp: u64,
        slot_max_amount: u64,
        minted_amount: u64,
        round: u64,
        qualified_round: u64,
        qualified_inscription_id: ID,
        qualified_hash: vector<u8>,
        qualified_timestamp: u64,
        qualified_difference: u64,
        candidate_inscription_id: ID,
        candidate_hash: vector<u8>,
        candidate_inscriber: address,
        candidate_timestamp: u64,
        candidate_amount: u64,
        candidate_nonce: u128,
        candidate_difference: u64,
        candidate_content: String,
    }

    public fun id(slot: &Slot): object::ID {
        object::uid_to_inner(&slot.id)
    }

    public fun slot_number(slot: &Slot): u8 {
        slot.slot_number
    }

    public fun version(slot: &Slot): u64 {
        slot.version
    }

    public fun genesis_timestamp(slot: &Slot): u64 {
        slot.genesis_timestamp
    }

    public(friend) fun set_genesis_timestamp(slot: &mut Slot, genesis_timestamp: u64) {
        slot.genesis_timestamp = genesis_timestamp;
    }

    public fun slot_max_amount(slot: &Slot): u64 {
        slot.slot_max_amount
    }

    public(friend) fun set_slot_max_amount(slot: &mut Slot, slot_max_amount: u64) {
        slot.slot_max_amount = slot_max_amount;
    }

    public fun minted_amount(slot: &Slot): u64 {
        slot.minted_amount
    }

    public(friend) fun set_minted_amount(slot: &mut Slot, minted_amount: u64) {
        slot.minted_amount = minted_amount;
    }

    public fun round(slot: &Slot): u64 {
        slot.round
    }

    public(friend) fun set_round(slot: &mut Slot, round: u64) {
        slot.round = round;
    }

    public fun qualified_round(slot: &Slot): u64 {
        slot.qualified_round
    }

    public(friend) fun set_qualified_round(slot: &mut Slot, qualified_round: u64) {
        slot.qualified_round = qualified_round;
    }

    public fun qualified_inscription_id(slot: &Slot): ID {
        slot.qualified_inscription_id
    }

    public(friend) fun set_qualified_inscription_id(slot: &mut Slot, qualified_inscription_id: ID) {
        slot.qualified_inscription_id = qualified_inscription_id;
    }

    public fun qualified_hash(slot: &Slot): vector<u8> {
        slot.qualified_hash
    }

    public(friend) fun set_qualified_hash(slot: &mut Slot, qualified_hash: vector<u8>) {
        slot.qualified_hash = qualified_hash;
    }

    public fun qualified_timestamp(slot: &Slot): u64 {
        slot.qualified_timestamp
    }

    public(friend) fun set_qualified_timestamp(slot: &mut Slot, qualified_timestamp: u64) {
        slot.qualified_timestamp = qualified_timestamp;
    }

    public fun qualified_difference(slot: &Slot): u64 {
        slot.qualified_difference
    }

    public(friend) fun set_qualified_difference(slot: &mut Slot, qualified_difference: u64) {
        slot.qualified_difference = qualified_difference;
    }

    public fun candidate_inscription_id(slot: &Slot): ID {
        slot.candidate_inscription_id
    }

    public(friend) fun set_candidate_inscription_id(slot: &mut Slot, candidate_inscription_id: ID) {
        slot.candidate_inscription_id = candidate_inscription_id;
    }

    public fun candidate_hash(slot: &Slot): vector<u8> {
        slot.candidate_hash
    }

    public(friend) fun set_candidate_hash(slot: &mut Slot, candidate_hash: vector<u8>) {
        slot.candidate_hash = candidate_hash;
    }

    public fun candidate_inscriber(slot: &Slot): address {
        slot.candidate_inscriber
    }

    public(friend) fun set_candidate_inscriber(slot: &mut Slot, candidate_inscriber: address) {
        slot.candidate_inscriber = candidate_inscriber;
    }

    public fun candidate_timestamp(slot: &Slot): u64 {
        slot.candidate_timestamp
    }

    public(friend) fun set_candidate_timestamp(slot: &mut Slot, candidate_timestamp: u64) {
        slot.candidate_timestamp = candidate_timestamp;
    }

    public fun candidate_amount(slot: &Slot): u64 {
        slot.candidate_amount
    }

    public(friend) fun set_candidate_amount(slot: &mut Slot, candidate_amount: u64) {
        slot.candidate_amount = candidate_amount;
    }

    public fun candidate_nonce(slot: &Slot): u128 {
        slot.candidate_nonce
    }

    public(friend) fun set_candidate_nonce(slot: &mut Slot, candidate_nonce: u128) {
        slot.candidate_nonce = candidate_nonce;
    }

    public fun candidate_difference(slot: &Slot): u64 {
        slot.candidate_difference
    }

    public(friend) fun set_candidate_difference(slot: &mut Slot, candidate_difference: u64) {
        slot.candidate_difference = candidate_difference;
    }

    public fun candidate_content(slot: &Slot): String {
        slot.candidate_content
    }

    public(friend) fun set_candidate_content(slot: &mut Slot, candidate_content: String) {
        assert!(std::string::length(&candidate_content) <= 1000, EDataTooLong);
        slot.candidate_content = candidate_content;
    }

    public fun admin_cap(slot: &Slot): ID {
        slot.admin_cap
    }

    fun new_slot(
        slot_number: u8,
        genesis_timestamp: u64,
        slot_max_amount: u64,
        qualified_inscription_id: ID,
        qualified_hash: vector<u8>,
        qualified_timestamp: u64,
        qualified_difference: u64,
        candidate_inscription_id: ID,
        candidate_hash: vector<u8>,
        candidate_inscriber: address,
        candidate_timestamp: u64,
        candidate_amount: u64,
        candidate_nonce: u128,
        candidate_difference: u64,
        candidate_content: String,
        ctx: &mut TxContext,
    ): Slot {
        assert!(std::string::length(&candidate_content) <= 1000, EDataTooLong);
        let admin_cap = AdminCap {
            id: object::new(ctx),
        };
        let admin_cap_id = object::id(&admin_cap);
        transfer::transfer(admin_cap, sui::tx_context::sender(ctx));
        Slot {
            id: object::new(ctx),
            slot_number,
            version: 0,
            schema_version: SCHEMA_VERSION,
            admin_cap: admin_cap_id,
            genesis_timestamp,
            slot_max_amount,
            minted_amount: 0,
            round: 0,
            qualified_round: 0,
            qualified_inscription_id,
            qualified_hash,
            qualified_timestamp,
            qualified_difference,
            candidate_inscription_id,
            candidate_hash,
            candidate_inscriber,
            candidate_timestamp,
            candidate_amount,
            candidate_nonce,
            candidate_difference,
            candidate_content,
        }
    }

    entry fun migrate(slot: &mut Slot, a: &AdminCap) {
        assert!(slot.admin_cap == object::id(a), ENotAdmin);
        assert!(slot.schema_version < SCHEMA_VERSION, ENotUpgrade);
        slot.schema_version = SCHEMA_VERSION;
    }

    struct SlotCreated has copy, drop {
        id: option::Option<object::ID>,
        slot_number: u8,
        genesis_timestamp: u64,
        slot_max_amount: u64,
    }

    public fun slot_created_id(slot_created: &SlotCreated): option::Option<object::ID> {
        slot_created.id
    }

    public(friend) fun set_slot_created_id(slot_created: &mut SlotCreated, id: object::ID) {
        slot_created.id = option::some(id);
    }

    public fun slot_created_slot_number(slot_created: &SlotCreated): u8 {
        slot_created.slot_number
    }

    public fun slot_created_genesis_timestamp(slot_created: &SlotCreated): u64 {
        slot_created.genesis_timestamp
    }

    public fun slot_created_slot_max_amount(slot_created: &SlotCreated): u64 {
        slot_created.slot_max_amount
    }

    public(friend) fun new_slot_created(
        slot_number: u8,
        genesis_timestamp: u64,
        slot_max_amount: u64,
    ): SlotCreated {
        SlotCreated {
            id: option::none(),
            slot_number,
            genesis_timestamp,
            slot_max_amount,
        }
    }

    struct CandidateInscriptionPutUpV2 has copy, drop {
        id: object::ID,
        slot_number: u8,
        version: u64,
        candidate_inscription_id: ID,
        round: u64,
        candidate_hash: vector<u8>,
        candidate_inscriber: address,
        candidate_timestamp: u64,
        candidate_amount: u64,
        candidate_nonce: u128,
        candidate_difference: u64,
        candidate_content: String,
        successful: bool,
    }

    public fun candidate_inscription_put_up_v2_id(candidate_inscription_put_up_v2: &CandidateInscriptionPutUpV2): object::ID {
        candidate_inscription_put_up_v2.id
    }

    public fun candidate_inscription_put_up_v2_slot_number(candidate_inscription_put_up_v2: &CandidateInscriptionPutUpV2): u8 {
        candidate_inscription_put_up_v2.slot_number
    }

    public fun candidate_inscription_put_up_v2_candidate_inscription_id(candidate_inscription_put_up_v2: &CandidateInscriptionPutUpV2): ID {
        candidate_inscription_put_up_v2.candidate_inscription_id
    }

    public fun candidate_inscription_put_up_v2_round(candidate_inscription_put_up_v2: &CandidateInscriptionPutUpV2): u64 {
        candidate_inscription_put_up_v2.round
    }

    public fun candidate_inscription_put_up_v2_candidate_hash(candidate_inscription_put_up_v2: &CandidateInscriptionPutUpV2): vector<u8> {
        candidate_inscription_put_up_v2.candidate_hash
    }

    public fun candidate_inscription_put_up_v2_candidate_inscriber(candidate_inscription_put_up_v2: &CandidateInscriptionPutUpV2): address {
        candidate_inscription_put_up_v2.candidate_inscriber
    }

    public fun candidate_inscription_put_up_v2_candidate_timestamp(candidate_inscription_put_up_v2: &CandidateInscriptionPutUpV2): u64 {
        candidate_inscription_put_up_v2.candidate_timestamp
    }

    public fun candidate_inscription_put_up_v2_candidate_amount(candidate_inscription_put_up_v2: &CandidateInscriptionPutUpV2): u64 {
        candidate_inscription_put_up_v2.candidate_amount
    }

    public fun candidate_inscription_put_up_v2_candidate_nonce(candidate_inscription_put_up_v2: &CandidateInscriptionPutUpV2): u128 {
        candidate_inscription_put_up_v2.candidate_nonce
    }

    public fun candidate_inscription_put_up_v2_candidate_difference(candidate_inscription_put_up_v2: &CandidateInscriptionPutUpV2): u64 {
        candidate_inscription_put_up_v2.candidate_difference
    }

    public fun candidate_inscription_put_up_v2_candidate_content(candidate_inscription_put_up_v2: &CandidateInscriptionPutUpV2): String {
        candidate_inscription_put_up_v2.candidate_content
    }

    public fun candidate_inscription_put_up_v2_successful(candidate_inscription_put_up_v2: &CandidateInscriptionPutUpV2): bool {
        candidate_inscription_put_up_v2.successful
    }

    public(friend) fun new_candidate_inscription_put_up_v2(
        slot: &Slot,
        candidate_inscription_id: ID,
        round: u64,
        candidate_hash: vector<u8>,
        candidate_inscriber: address,
        candidate_timestamp: u64,
        candidate_amount: u64,
        candidate_nonce: u128,
        candidate_difference: u64,
        candidate_content: String,
        successful: bool,
    ): CandidateInscriptionPutUpV2 {
        CandidateInscriptionPutUpV2 {
            id: id(slot),
            slot_number: slot_number(slot),
            version: version(slot),
            candidate_inscription_id,
            round,
            candidate_hash,
            candidate_inscriber,
            candidate_timestamp,
            candidate_amount,
            candidate_nonce,
            candidate_difference,
            candidate_content,
            successful,
        }
    }

    struct CandidateInscriptionPutUp has copy, drop {
        id: object::ID,
        slot_number: u8,
        version: u64,
        candidate_inscription_id: ID,
        round: u64,
        candidate_hash: vector<u8>,
        candidate_inscriber: address,
        candidate_timestamp: u64,
        candidate_amount: u64,
        candidate_nonce: u128,
        candidate_difference: u64,
        candidate_content: String,
        successful: bool,
    }

    public fun candidate_inscription_put_up_id(candidate_inscription_put_up: &CandidateInscriptionPutUp): object::ID {
        candidate_inscription_put_up.id
    }

    public fun candidate_inscription_put_up_slot_number(candidate_inscription_put_up: &CandidateInscriptionPutUp): u8 {
        candidate_inscription_put_up.slot_number
    }

    public fun candidate_inscription_put_up_candidate_inscription_id(candidate_inscription_put_up: &CandidateInscriptionPutUp): ID {
        candidate_inscription_put_up.candidate_inscription_id
    }

    public fun candidate_inscription_put_up_round(candidate_inscription_put_up: &CandidateInscriptionPutUp): u64 {
        candidate_inscription_put_up.round
    }

    public fun candidate_inscription_put_up_candidate_hash(candidate_inscription_put_up: &CandidateInscriptionPutUp): vector<u8> {
        candidate_inscription_put_up.candidate_hash
    }

    public fun candidate_inscription_put_up_candidate_inscriber(candidate_inscription_put_up: &CandidateInscriptionPutUp): address {
        candidate_inscription_put_up.candidate_inscriber
    }

    public fun candidate_inscription_put_up_candidate_timestamp(candidate_inscription_put_up: &CandidateInscriptionPutUp): u64 {
        candidate_inscription_put_up.candidate_timestamp
    }

    public fun candidate_inscription_put_up_candidate_amount(candidate_inscription_put_up: &CandidateInscriptionPutUp): u64 {
        candidate_inscription_put_up.candidate_amount
    }

    public fun candidate_inscription_put_up_candidate_nonce(candidate_inscription_put_up: &CandidateInscriptionPutUp): u128 {
        candidate_inscription_put_up.candidate_nonce
    }

    public fun candidate_inscription_put_up_candidate_difference(candidate_inscription_put_up: &CandidateInscriptionPutUp): u64 {
        candidate_inscription_put_up.candidate_difference
    }

    public fun candidate_inscription_put_up_candidate_content(candidate_inscription_put_up: &CandidateInscriptionPutUp): String {
        candidate_inscription_put_up.candidate_content
    }

    public fun candidate_inscription_put_up_successful(candidate_inscription_put_up: &CandidateInscriptionPutUp): bool {
        candidate_inscription_put_up.successful
    }

    public(friend) fun new_candidate_inscription_put_up(
        slot: &Slot,
        candidate_inscription_id: ID,
        round: u64,
        candidate_hash: vector<u8>,
        candidate_inscriber: address,
        candidate_timestamp: u64,
        candidate_amount: u64,
        candidate_nonce: u128,
        candidate_difference: u64,
        candidate_content: String,
        successful: bool,
    ): CandidateInscriptionPutUp {
        CandidateInscriptionPutUp {
            id: id(slot),
            slot_number: slot_number(slot),
            version: version(slot),
            candidate_inscription_id,
            round,
            candidate_hash,
            candidate_inscriber,
            candidate_timestamp,
            candidate_amount,
            candidate_nonce,
            candidate_difference,
            candidate_content,
            successful,
        }
    }

    struct SlotAdvanced has copy, drop {
        id: object::ID,
        slot_number: u8,
        version: u64,
        round: u64,
    }

    public fun slot_advanced_id(slot_advanced: &SlotAdvanced): object::ID {
        slot_advanced.id
    }

    public fun slot_advanced_slot_number(slot_advanced: &SlotAdvanced): u8 {
        slot_advanced.slot_number
    }

    public fun slot_advanced_round(slot_advanced: &SlotAdvanced): u64 {
        slot_advanced.round
    }

    public(friend) fun new_slot_advanced(
        slot: &Slot,
        round: u64,
    ): SlotAdvanced {
        SlotAdvanced {
            id: id(slot),
            slot_number: slot_number(slot),
            version: version(slot),
            round,
        }
    }


    public(friend) fun create_slot(
        slot_number: u8,
        genesis_timestamp: u64,
        slot_max_amount: u64,
        qualified_inscription_id: ID,
        qualified_hash: vector<u8>,
        qualified_timestamp: u64,
        qualified_difference: u64,
        candidate_inscription_id: ID,
        candidate_hash: vector<u8>,
        candidate_inscriber: address,
        candidate_timestamp: u64,
        candidate_amount: u64,
        candidate_nonce: u128,
        candidate_difference: u64,
        candidate_content: String,
        slot_number_table: &mut SlotNumberTable,
        ctx: &mut TxContext,
    ): Slot {
        let slot = new_slot(
            slot_number,
            genesis_timestamp,
            slot_max_amount,
            qualified_inscription_id,
            qualified_hash,
            qualified_timestamp,
            qualified_difference,
            candidate_inscription_id,
            candidate_hash,
            candidate_inscriber,
            candidate_timestamp,
            candidate_amount,
            candidate_nonce,
            candidate_difference,
            candidate_content,
            ctx,
        );
        asset_slot_number_not_exists_then_add(slot_number, slot_number_table, object::uid_to_inner(&slot.id));
        slot
    }

    public(friend) fun asset_slot_number_not_exists(
        slot_number: u8,
        slot_number_table: &SlotNumberTable,
    ) {
        assert!(!table::contains(&slot_number_table.table, slot_number), EIdAlreadyExists);
    }

    fun asset_slot_number_not_exists_then_add(
        slot_number: u8,
        slot_number_table: &mut SlotNumberTable,
        id: object::ID,
    ) {
        asset_slot_number_not_exists(slot_number, slot_number_table);
        table::add(&mut slot_number_table.table, slot_number, id);
    }

    public(friend) fun transfer_object(slot: Slot, recipient: address) {
        assert!(slot.version == 0, EInappropriateVersion);
        transfer::transfer(slot, recipient);
    }

    public(friend) fun update_version_and_transfer_object(slot: Slot, recipient: address) {
        update_object_version(&mut slot);
        transfer::transfer(slot, recipient);
    }

    #[lint_allow(share_owned)]
    public(friend) fun share_object(slot: Slot) {
        assert!(slot.version == 0, EInappropriateVersion);
        transfer::share_object(slot);
    }

    public(friend) fun freeze_object(slot: Slot) {
        assert!(slot.version == 0, EInappropriateVersion);
        transfer::freeze_object(slot);
    }

    public(friend) fun update_version_and_freeze_object(slot: Slot) {
        update_object_version(&mut slot);
        transfer::freeze_object(slot);
    }

    public(friend) fun update_object_version(slot: &mut Slot) {
        slot.version = slot.version + 1;
        //assert!(slot.version != 0, EInappropriateVersion);
    }

    public(friend) fun drop_slot(slot: Slot) {
        let Slot {
            id,
            slot_number: _slot_number,
            version: _version,
            schema_version: _,
            admin_cap: _,
            genesis_timestamp: _genesis_timestamp,
            slot_max_amount: _slot_max_amount,
            minted_amount: _minted_amount,
            round: _round,
            qualified_round: _qualified_round,
            qualified_inscription_id: _qualified_inscription_id,
            qualified_hash: _qualified_hash,
            qualified_timestamp: _qualified_timestamp,
            qualified_difference: _qualified_difference,
            candidate_inscription_id: _candidate_inscription_id,
            candidate_hash: _candidate_hash,
            candidate_inscriber: _candidate_inscriber,
            candidate_timestamp: _candidate_timestamp,
            candidate_amount: _candidate_amount,
            candidate_nonce: _candidate_nonce,
            candidate_difference: _candidate_difference,
            candidate_content: _candidate_content,
        } = slot;
        object::delete(id);
    }

    public(friend) fun emit_slot_created(slot_created: SlotCreated) {
        assert!(std::option::is_some(&slot_created.id), EEmptyObjectID);
        event::emit(slot_created);
    }

    public(friend) fun emit_candidate_inscription_put_up_v2(candidate_inscription_put_up_v2: CandidateInscriptionPutUpV2) {
        event::emit(candidate_inscription_put_up_v2);
    }

    public(friend) fun emit_candidate_inscription_put_up(candidate_inscription_put_up: CandidateInscriptionPutUp) {
        event::emit(candidate_inscription_put_up);
    }

    public(friend) fun emit_slot_advanced(slot_advanced: SlotAdvanced) {
        event::emit(slot_advanced);
    }

    #[test_only]
    /// Wrapper of module initializer for testing
    public fun test_init(ctx: &mut TxContext) {
        init(ctx)
    }

}
