# Sui Move 原生铭文 ddda 即刻开打！

合约已经部署！ ddda 就是“Diao Diao Da”！

并且，我们开发了一个用于查询的链下服务，有时候这个服务也被称为 indexer，
但是，需要说明的是：作为一个 Sui Move 智能合约原生铭文，ddda 的“最终状态”**不依赖**链下 indexer 的解释！而是由智能合约的状态表示的。
我们认为这才是智能合约平台型公链铭文的正确玩法。

需要说明的是，当前 Move 社区内关于“智能（合约）铭文”的探索尚在进行。（但是我们已经迫不及待了！）

我们承诺：当 Move 社区对此问题形成共识时，我们将发布新版的智能合约；届时你可以将这个版本的 ddda 铭文对象发送到新版合约，销毁同时获得等价的（符合社区共识的）新版铭文对象！

## 供应量

ddda 铭文的铸造总量为 2100 万亿个最小单位。

合约提供 210 个卡槽。卡槽每 2.5 分钟（一轮）可以生产一张铭文。 每张铭文铸造的限制数量为 385802469（最小单位）。

如果卡槽全速运转（大家的热情足够，每次都铸造最大数量），所有铭文将在一个半月内铸造完毕。

## 铸造规则说明

铭文铸造成功的规则如果用一句话来概括，那就是： 如果当前轮次（round）你所铸造的铭文的哈希值，和前一轮铸造成功的铭文的哈希值，长得足够像（即“差异”足够小），那么你的铭文在这轮就可以“胜出”。

因为铭文的哈希值是铸造过程中随机产生的，所以，你需要先铸造一个铭文，然后拿着它和其他竞争者进行比较，直到本轮时间结束，才能确定最终的胜利者（qualified inscription）。

合约会为每轮次胜出的铭文颁发一个对应的“证书”对象，铭文的信息会拷贝到这个证书对象。然后，大家就可以将已经“过期”的铭文对象销毁，为“链”节省存储空间，以及回收 gas 费用。

> **温馨提示**
> 
> 铭文合约具备升级机制，哈希和差异比较算法可能不定期更改（升级后对外暴露的接口不变）。原则上鼓励大家手搓 PoW，不鼓励大资源投入算力 + 联合矿工做“过度科学化”的努力。

## 前提条件

安装好 sui 命令行工具！

* Install [Sui](https://docs.sui.io/build/install).

即可按照下面的说明开打！

**对了，跪求前端高手小伙伴加入**，一起开发打 ddda 铭文的 Web GUI！

## 使用 Sui CLI 打 ddda 铭文

当前 Sui 主网上 ddda 铭文合约的 package Id 为 `0x776fbac3115141986702630edf576b42adbcf60dc86a56a5875703fe817b670e`。
当你执行下面的命令时候，需要注意将占位符 `{PACKAGE_ID}` 替换为这个值。

### 观察卡槽的状态

卡槽的信息，编号以及对应的卡槽对象 Id，见本文档最后一节。

选择任意一个卡槽，将卡槽对象 Id 替换下面的命令中的占位符 `{SLOT_OBJECT_ID}`，然后执行：

```shell
sui client object {SLOT_OBJECT_ID} --json
```

观察命令输出的卡槽状态信息，类似：

```json
{
  "fields": {
    // ...
    "candidate_difference": "113430341", // 当前候选铭文的差异值
    // ...
    "qualified_difference": "113430341", // 上一轮胜出的铭文的差异值
    // ...
    "round": "2", // 当前轮次
    // ...
    "slot_number": 209, // 卡槽编号
    // ...
  }
}
```

你可以将“差异值”（`difference`）理解为反比的“难度”。即差异值越小，表示你想要在这个卡槽中铸造成功的难度越大。平均值为 128000000。

如果输出中的 `candidate_difference` 与 `qualified_difference` 相等，一般说明当前轮次刚刚开始。
当然，我们其实有另外的字段来标识本轮是否刚刚开始。代码已经开源！这里不再赘述。

当轮次刚开始时，你想要“推入”卡槽的铭文，其差异值只需要和上一轮胜出铭文的差异值（`qualified_difference`）相当（比较差异值的前三位），既可以成功占据卡槽，成为当前轮次的“候选者”；
否则，你的铭文的差异值（`candidate_difference`）必须**小于**当前卡槽内已经存在的候选者的差异值。

### 铸造铭文

选择一个你中意的卡槽，比如说编号为 209 的卡槽，为它铸造一个铭文（注意把占位符 {ROUND} 替换为卡槽的当前轮次）：


```shell
sui client call --package {PACKAGE_ID} --module inscription_aggregate --function mint \
--args 209 \"{ROUND}\" \"385802469\" \"123456\" '"hello-world!"' \"0x6\" \
--gas-budget 1000000000
```

以上命令调用的智能合约函数，其各个参数的含义解释如下：

* 第一个参数是卡槽编号（slot_number）。
* 当前轮次（round）。使用观察卡槽状态得到的结果。
* 铸造数量（amount）。你可以直接选择铸造最大数量，385802469。
* 你选择的随机数（nonce），会影响生成的铭文对象的哈希。
* 内容（content）。填入你喜欢的任意内容，比如“我爱🇰🇵金元帅”，长度不要超过 1000 个字就行。 
* Sui 时钟（clock）对象的 Id。固定为 `0x6`。

上面的命令如果执行成功，输出类似：

```text
[TBD]
```

### 尝试将铭文推入卡槽

将下面的命令中的占位符 `{SLOT_OBJECT_ID}` 替换为卡槽对象的 Id；将占位符 `{INSCRIPTION_OBJECT_ID}` 替换为你的铭文对象的 Id。然后执行：

```shell
sui client call --package {PACKAGE_ID} --module slot_aggregate --function put_up_candidate \
--args {SLOT_OBJECT_ID} \"{INSCRIPTION_OBJECT_ID}\" \"0x6\" \
--gas-budget 1000000000
```

如果成功，你得到的输出类似：

```text
[TBD]
```

当然，尝试是有可能失败的，因为可能存在其他竞争者的铭文“差异值”比你的铭文小。

### 将卡槽推进到下一轮次

因为智能合约没有“定时任务”的概念。所以，当每个轮次时间结束，我们需要有人主动调用合约函数，将游戏推进到下一轮（如果你想要参加下一轮铸造，你只能先做这一步）。

任何人都可以执行下面的命令，将卡槽状态推进到下一轮：

```shell
sui client call --package {PACKAGE_ID} --module slot_aggregate --function advance \
--args {SLOT_OBJECT_ID} \"0x6\" \
--gas-budget 1000000000
```

此时，该轮次的胜出者就会收到一张“铭文证书”（`0x...::certificate::Certificate`）。

然后，大家就可以重新回到上面描述的“铸造铭文”那一步，继续游戏！

--------

你可以使用下面的命令，查看你的账户中都有几张铭文证书：

```shell
sui client objects
```

输出中每段类似下面这样的内容，都表示你成功铸造了一张铭文：

```text
│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │
│ │ objectId   │  0xfbd088d50875f33c51a8dd55e4de31adca2fb3d5bab4db9369e156934e5a00ba  │ │
│ │ version    │  89830                                                               │ │
│ │ digest     │  Hn02ES2iw0CP0eIMRI/enx3Y0jUaO5wdwF/ckc6GqBQ=                        │ │
│ │ objectType │  0x5109..d7b3::certificate::Certificate                              │ │
│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │
```


## 卡槽信息

卡槽的编号以及对应的卡槽对象 Id 如下：

```text
[TBD]
```
